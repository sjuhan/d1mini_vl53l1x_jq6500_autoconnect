/*
  FSBrowser - A web-based FileSystem Browser for ESP8266 filesystems

  Copyright (c) 2015 Hristo Gochkov. All rights reserved.
  This file is part of the ESP8266WebServer library for Arduino environment.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

  See readme.md for more information.
*/

////////////////////////////////

// Select the FileSystem by uncommenting one of the lines below

//#define USE_SPIFFS
#define USE_LITTLEFS
//#define USE_SDFS

// Uncomment the following line to embed a version of the web page in the code
// (program code will be larger, but no file will have to be written to the filesystem).
// Note: the source file "extras/index_htm.h" must have been generated by "extras/reduce_index.sh"

//#define INCLUDE_FALLBACK_INDEX_HTM

////////////////////////////////

#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#define GET_CHIPID() (ESP.getChipId())
#include <WiFiClient.h>
#include <ESP8266WebServer.h>
#include <ESP8266HTTPUpdateServer.h>
using WebServerClass = ESP8266WebServer;
using HTTPUpdateServerClass = ESP8266HTTPUpdateServer;
#include <SPI.h>
#include <PubSubClient.h>
#include <AutoConnect.h>
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#include <Wire.h>
#include "SparkFun_VL53L1X.h"
#include <SoftwareSerial.h>
#include <JQ6500_Serial.h>

#define BTN_PIN 0
#define BUILTIN_LED 2

#define D0 16
#define D1 5  //scl
#define D2 4  //sda
#define D3 0  //HIGH Run, LOW Flash,10k Pull-up
#define D4 2  //10k pull-up, BUILTIN_LED
#define D5 14 //SCK
#define D6 12 //MISO
#define D7 13 //MOSI
#define D8 15 //10k pull-down, SS

JQ6500_Serial mp3(D6, D5);

SFEVL53L1X distanceSensor(Wire); //, SHUTDOWN_PIN, INTERRUPT_PIN);

int count, count1, token, bt, button, longpress, Distance0 = 0;
int threadhold, direction, led1, led2, btn, modality;
unsigned long t0;
unsigned long t;

unsigned long dtime0;
unsigned long dtime1;

static int NOBODY = 0;
static int SOMEONE = 1;
static int LEFT = 0;

static int PathTrack[] = {0, 0, 0, 0};
static int PathTrackFillingSize = 1; // init this to 1 as we start from state where nobody is any of the zones
static int LeftPreviousStatus = NOBODY;
static int RightPreviousStatus = NOBODY;
static int PeopleCount = 0;
// 195,60
// 167, 231
static int center[2] = {167, 231}; // {21, 85}; these are the spad center of the 2 8*16 zones */ //239, 175, bassi: 35, 99
// 175: quasi sempre sopra i due metri, mai sotto i 1800
// 239: quasi sempre tra i 1500 e i 2000
static int Zone = 0;

static int ROI_height = 7;
static int ROI_width = 7;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef INCLUDE_FALLBACK_INDEX_HTM
#include "extras/index_htm.h"
#endif

#if defined USE_SPIFFS
#include <FS.h>
const char *fsName = "SPIFFS";
FS *fileSystem = &SPIFFS;
SPIFFSConfig fileSystemConfig = SPIFFSConfig();
#elif defined USE_LITTLEFS
#include <LittleFS.h>
const char *fsName = "LittleFS";
FS *fileSystem = &LittleFS;
FS &FlashFS = LittleFS;
LittleFSConfig fileSystemConfig = LittleFSConfig();
#elif defined USE_SDFS
#include <SDFS.h>
const char *fsName = "SDFS";
FS *fileSystem = &SDFS;
SDFSConfig fileSystemConfig = SDFSConfig();
// fileSystemConfig.setCSPin(chipSelectPin);
#else
#error Please select a filesystem first by uncommenting one of the "#define USE_xxx" lines at the beginning of the sketch.
#endif

//////////////////
#define PARAM_FILE "/param.json"
#define AUX_MQTTSETTING "/mqtt_setting"
#define AUX_MQTTSAVE "/mqtt_save"
#define AUX_MQTTCLEAR "/mqtt_clear"

#define SETTING_PARAM_FILE "/setting_param.json"
#define AUX_SETTING "/setting"
#define AUX_SETTINGSAVE "/setting_save"

// Adjusting WebServer class with between ESP8266 and ESP32.
#if defined(ARDUINO_ARCH_ESP8266)
typedef ESP8266WebServer WiFiWebServer;
#elif defined(ARDUINO_ARCH_ESP32)
typedef WebServer WiFiWebServer;
#endif
//////////////////

#define DBG_OUTPUT_PORT Serial

// Exclude unnecessary declarations due to applying AutoConnect
// #ifndef STASSID
// #define STASSID "your-ssid"
// #define STAPSK  "your-password"
// #endif

// const char* ssid = STASSID;
// const char* password = STAPSK;

ESP8266WebServer server(80);

#define USERNAME "user" //*< Replace the actual username you want */
#define PASSWORD "pass" //*< Replace the actual password you want */
// Declare AutoConnectAux to bind the HTTPWebUpdateServer via /update url
// and call it from the menu.
// The custom web page is an empty page that does not contain AutoConnectElements.
// Its content will be emitted by ESP8266HTTPUpdateServer.
HTTPUpdateServerClass httpUpdater;
AutoConnectAux update("/update", "Update");

static bool fsOK;
String unsupportedFiles = String();

File uploadFile;

// Additional lines as the below to apply AutoConnect
AutoConnect portal(server);
AutoConnectConfig config;
WiFiClient wifiClient;
PubSubClient mqttClient(wifiClient);
String serverName;
String channelId;
String userKey;
String apiKey;
String apid;
String hostName;
unsigned int updateInterval = 0;
unsigned long lastPub = 0;

#define MQTT_USER_ID "anyone"

static const char TEXT_PLAIN[] PROGMEM = "text/plain";
static const char FS_INIT_ERROR[] PROGMEM = "FS INIT ERROR";
static const char FILE_NOT_FOUND[] PROGMEM = "FileNotFound";

///////////////MQTT

bool mqttConnect()
{
  static const char alphanum[] = "0123456789"
                                 "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                                 "abcdefghijklmnopqrstuvwxyz"; // For random generation of client ID.
  char clientId[9];

  uint8_t retry = 3;
  while (!mqttClient.connected())
  {
    if (serverName.length() <= 0)
      break;

    mqttClient.setServer(serverName.c_str(), 1883);
    Serial.println(String("Attempting MQTT broker:") + serverName);

    for (uint8_t i = 0; i < 8; i++)
    {
      clientId[i] = alphanum[random(62)];
    }
    clientId[8] = '\0';

    if (mqttClient.connect(clientId, MQTT_USER_ID, userKey.c_str()))
    {
      Serial.println("Established:" + String(clientId));
      return true;
    }
    else
    {
      Serial.println("Connection failed:" + String(mqttClient.state()));
      if (!--retry)
        break;
      delay(3000);
    }
  }
  return false;
}

void mqttPublish(String msg)
{
  String path = String("channels/") + channelId + String("/publish/") + apiKey;
  mqttClient.publish(path.c_str(), msg.c_str());
}

int getStrength(uint8_t points)
{
  uint8_t sc = points;
  long rssi = 0;

  while (sc--)
  {
    rssi += WiFi.RSSI();
    delay(20);
  }
  return points ? static_cast<int>(rssi / points) : 0;
}

String loadParams(AutoConnectAux &aux, PageArgument &args)
{
  (void)(args);
  File param = FlashFS.open(PARAM_FILE, "r");
  if (param)
  {
    aux.loadElement(param);
    param.close();
  }
  else
    Serial.println(PARAM_FILE " open failed");
  return String("");
}

String loadSETTINGParams(AutoConnectAux &aux, PageArgument &args)
{
  (void)(args);
  File param = FlashFS.open(SETTING_PARAM_FILE, "r");
  if (param)
  {
    aux.loadElement(param);
    param.close();
  }
  else
    Serial.println(SETTING_PARAM_FILE " open failed");
  return String("");
}

String saveParams(AutoConnectAux &aux, PageArgument &args)
{
  serverName = args.arg("mqttserver");
  serverName.trim();

  channelId = args.arg("channelid");
  channelId.trim();

  userKey = args.arg("userkey");
  userKey.trim();

  apiKey = args.arg("apikey");
  apiKey.trim();

  String upd = args.arg("period");
  updateInterval = upd.substring(0, 2).toInt() * 1000;

  String uniqueid = args.arg("uniqueid");

  hostName = args.arg("hostname");
  hostName.trim();

  // The entered value is owned by AutoConnectAux of /mqtt_setting.
  // To retrieve the elements of /mqtt_setting, it is necessary to get
  // the AutoConnectAux object of /mqtt_setting.
  File param = FlashFS.open(PARAM_FILE, "w");
  portal.aux("/mqtt_setting")->saveElement(param, {"mqttserver", "channelid", "userkey", "apikey", "period", "uniqueid", "hostname", "modality"});
  param.close();

  // Echo back saved parameters to AutoConnectAux page.
  AutoConnectText &echo = aux["parameters"].as<AutoConnectText>();
  echo.value = "Server: " + serverName + "<br>";
  echo.value += "Channel ID: " + channelId + "<br>";
  echo.value += "User Key: " + userKey + "<br>";
  echo.value += "API Key: " + apiKey + "<br>";
  echo.value += "Update period: " + String(updateInterval / 1000) + " sec.<br>";
  echo.value += "Use APID unique: " + uniqueid + "<br>";
  echo.value += "ESP host name: " + hostName + "<br>";

  return String("");
}

String saveSETTINGParams(AutoConnectAux &aux, PageArgument &args)
{
  String threadhold = args.arg("threadhold");
  threadhold.trim();

  String direction = args.arg("direction");
  direction.trim();

  String led1 = args.arg("led1");
  led1.trim();

  String led2 = args.arg("led2");
  led2.trim();

  String button = args.arg("button");
  button.trim();

  String modality = args.arg("modality");
  modality.trim();

  // The entered value is owned by AutoConnectAux of /setting.
  // To retrieve the elements of /setting, it is necessary to get
  // the AutoConnectAux object of /setting.
  File param = FlashFS.open(SETTING_PARAM_FILE, "w");
  portal.aux("/setting")->saveElement(param, {"threadhold", "direction", "led1", "led2", "button", "modality"});
  param.close();

  // Echo back saved parameters to AutoConnectAux page.
  AutoConnectText &echo = aux["parameters"].as<AutoConnectText>();
  echo.value = "감지거리: " + threadhold + "<br>";
  echo.value += "감지방향: " + direction + "<br>";
  echo.value += "LED1: " + led1 + "<br>";
  echo.value += "LED2: " + led2 + "<br>";
  echo.value += "버튼: " + button + " <br>";
  echo.value += "검사실: " + modality + "<br>";

  return String("");
}

// Clear channel using Thingspeak's API.
void handleClearChannel()
{
  HTTPClient httpClient;

  String endpoint = serverName;
  endpoint.replace("mqtt", "api");
  String delUrl = "http://" + endpoint + "/channels/" + channelId + "/feeds.json?api_key=" + userKey;

  Serial.print("DELETE " + delUrl);
  if (httpClient.begin(wifiClient, delUrl))
  {
    Serial.print(":");
    int resCode = httpClient.sendRequest("DELETE");
    const String &res = httpClient.getString();
    Serial.println(String(resCode) + String(",") + res);
    httpClient.end();
  }
  else
    Serial.println(" failed");

  // Returns the redirect response. The page is reloaded and its contents
  // are updated to the state after deletion.
  WiFiWebServer &webServer = portal.host();
  webServer.sendHeader("Location", String("http://") + webServer.client().localIP().toString() + String("/"));
  webServer.send(302, "text/plain", "");
  webServer.client().flush();
  webServer.client().stop();
}

// Load AutoConnectAux JSON from the flash on the board.
bool loadAux(const String auxName)
{
  bool rc = false;
  String fn = auxName + ".json";
  File fs = FlashFS.open(fn.c_str(), "r");
  if (fs)
  {
    rc = portal.load(fs);
    fs.close();
  }
  else
    Serial.println("Filesystem open failed: " + fn);
  return rc;
}
////////////////mqtt 끝

////////////////////////////////
// Utils to return HTTP codes, and determine content-type

void replyOK()
{
  server.send(200, FPSTR(TEXT_PLAIN), "");
}

void replyOKWithMsg(String msg)
{
  server.send(200, FPSTR(TEXT_PLAIN), msg);
}

void replyNotFound(String msg)
{
  server.send(404, FPSTR(TEXT_PLAIN), msg);
}

void replyBadRequest(String msg)
{
  DBG_OUTPUT_PORT.println(msg);
  server.send(400, FPSTR(TEXT_PLAIN), msg + "\r\n");
}

void replyServerError(String msg)
{
  DBG_OUTPUT_PORT.println(msg);
  server.send(500, FPSTR(TEXT_PLAIN), msg + "\r\n");
}

#ifdef USE_SPIFFS
/*
   Checks filename for character combinations that are not supported by FSBrowser (alhtough valid on SPIFFS).
   Returns an empty String if supported, or detail of error(s) if unsupported
*/
String checkForUnsupportedPath(String filename)
{
  String error = String();
  if (!filename.startsWith("/"))
  {
    error += F("!NO_LEADING_SLASH! ");
  }
  if (filename.indexOf("//") != -1)
  {
    error += F("!DOUBLE_SLASH! ");
  }
  if (filename.endsWith("/"))
  {
    error += F("!TRAILING_SLASH! ");
  }
  return error;
}
#endif

////////////////////////////////
// Request handlers

/*
   Return the FS type, status and size info
*/
void handleStatus()
{
  DBG_OUTPUT_PORT.println("handleStatus");
  FSInfo fs_info;
  String json;
  json.reserve(128);

  json = "{\"type\":\"";
  json += fsName;
  json += "\", \"isOk\":";
  if (fsOK)
  {
    fileSystem->info(fs_info);
    json += F("\"true\", \"totalBytes\":\"");
    json += fs_info.totalBytes;
    json += F("\", \"usedBytes\":\"");
    json += fs_info.usedBytes;
    json += "\"";
  }
  else
  {
    json += "\"false\"";
  }
  json += F(",\"unsupportedFiles\":\"");
  json += unsupportedFiles;
  json += "\"}";

  server.send(200, "application/json", json);
}

/*
   Return the list of files in the directory specified by the "dir" query string parameter.
   Also demonstrates the use of chuncked responses.
*/
void handleFileList()
{
  if (!fsOK)
  {
    return replyServerError(FPSTR(FS_INIT_ERROR));
  }

  if (!server.hasArg("dir"))
  {
    return replyBadRequest(F("DIR ARG MISSING"));
  }

  String path = server.arg("dir");
  if (path != "/" && !fileSystem->exists(path))
  {
    return replyBadRequest("BAD PATH");
  }

  DBG_OUTPUT_PORT.println(String("handleFileList: ") + path);
  Dir dir = fileSystem->openDir(path);
  path.clear();

  // use HTTP/1.1 Chunked response to avoid building a huge temporary string
  if (!server.chunkedResponseModeStart(200, "text/json"))
  {
    server.send(505, F("text/html"), F("HTTP1.1 required"));
    return;
  }

  // use the same string for every line
  String output;
  output.reserve(64);
  while (dir.next())
  {
#ifdef USE_SPIFFS
    String error = checkForUnsupportedPath(dir.fileName());
    if (error.length() > 0)
    {
      DBG_OUTPUT_PORT.println(String("Ignoring ") + error + dir.fileName());
      continue;
    }
#endif
    if (output.length())
    {
      // send string from previous iteration
      // as an HTTP chunk
      server.sendContent(output);
      output = ',';
    }
    else
    {
      output = '[';
    }

    output += "{\"type\":\"";
    if (dir.isDirectory())
    {
      output += "dir";
    }
    else
    {
      output += F("file\",\"size\":\"");
      output += dir.fileSize();
    }

    output += F("\",\"name\":\"");
    // Always return names without leading "/"
    if (dir.fileName()[0] == '/')
    {
      output += &(dir.fileName()[1]);
    }
    else
    {
      output += dir.fileName();
    }

    output += "\"}";
  }

  // send last string
  output += "]";
  server.sendContent(output);
  server.chunkedResponseFinalize();
}

/*
   Read the given file from the filesystem and stream it back to the client
*/
bool handleFileRead(String path)
{
  DBG_OUTPUT_PORT.println(String("handleFileRead: ") + path);
  if (!fsOK)
  {
    replyServerError(FPSTR(FS_INIT_ERROR));
    return true;
  }

  if (path.endsWith("/"))
  {
    path += "index.htm";
  }

  String contentType;
  if (server.hasArg("download"))
  {
    contentType = F("application/octet-stream");
  }
  else
  {
    contentType = mime::getContentType(path);
  }

  if (!fileSystem->exists(path))
  {
    // File not found, try gzip version
    path = path + ".gz";
  }
  if (fileSystem->exists(path))
  {
    File file = fileSystem->open(path, "r");
    if (server.streamFile(file, contentType) != file.size())
    {
      DBG_OUTPUT_PORT.println("Sent less data than expected!");
    }
    file.close();
    return true;
  }

  return false;
}

/*
   As some FS (e.g. LittleFS) delete the parent folder when the last child has been removed,
   return the path of the closest parent still existing
*/
String lastExistingParent(String path)
{
  while (!path.isEmpty() && !fileSystem->exists(path))
  {
    if (path.lastIndexOf('/') > 0)
    {
      path = path.substring(0, path.lastIndexOf('/'));
    }
    else
    {
      path = String(); // No slash => the top folder does not exist
    }
  }
  DBG_OUTPUT_PORT.println(String("Last existing parent: ") + path);
  return path;
}

/*
   Handle the creation/rename of a new file
   Operation      | req.responseText
   ---------------+--------------------------------------------------------------
   Create file    | parent of created file
   Create folder  | parent of created folder
   Rename file    | parent of source file
   Move file      | parent of source file, or remaining ancestor
   Rename folder  | parent of source folder
   Move folder    | parent of source folder, or remaining ancestor
*/
void handleFileCreate()
{
  if (!fsOK)
  {
    return replyServerError(FPSTR(FS_INIT_ERROR));
  }

  String path = server.arg("path");
  if (path.isEmpty())
  {
    return replyBadRequest(F("PATH ARG MISSING"));
  }

#ifdef USE_SPIFFS
  if (checkForUnsupportedPath(path).length() > 0)
  {
    return replyServerError(F("INVALID FILENAME"));
  }
#endif

  if (path == "/")
  {
    return replyBadRequest("BAD PATH");
  }
  if (fileSystem->exists(path))
  {
    return replyBadRequest(F("PATH FILE EXISTS"));
  }

  String src = server.arg("src");
  if (src.isEmpty())
  {
    // No source specified: creation
    DBG_OUTPUT_PORT.println(String("handleFileCreate: ") + path);
    if (path.endsWith("/"))
    {
      // Create a folder
      path.remove(path.length() - 1);
      if (!fileSystem->mkdir(path))
      {
        return replyServerError(F("MKDIR FAILED"));
      }
    }
    else
    {
      // Create a file
      File file = fileSystem->open(path, "w");
      if (file)
      {
        file.write((const char *)0);
        file.close();
      }
      else
      {
        return replyServerError(F("CREATE FAILED"));
      }
    }
    if (path.lastIndexOf('/') > -1)
    {
      path = path.substring(0, path.lastIndexOf('/'));
    }
    replyOKWithMsg(path);
  }
  else
  {
    // Source specified: rename
    if (src == "/")
    {
      return replyBadRequest("BAD SRC");
    }
    if (!fileSystem->exists(src))
    {
      return replyBadRequest(F("SRC FILE NOT FOUND"));
    }

    DBG_OUTPUT_PORT.println(String("handleFileCreate: ") + path + " from " + src);

    if (path.endsWith("/"))
    {
      path.remove(path.length() - 1);
    }
    if (src.endsWith("/"))
    {
      src.remove(src.length() - 1);
    }
    if (!fileSystem->rename(src, path))
    {
      return replyServerError(F("RENAME FAILED"));
    }
    replyOKWithMsg(lastExistingParent(src));
  }
}

/*
   Delete the file or folder designed by the given path.
   If it's a file, delete it.
   If it's a folder, delete all nested contents first then the folder itself

   IMPORTANT NOTE: using recursion is generally not recommended on embedded devices and can lead to crashes (stack overflow errors).
   This use is just for demonstration purpose, and FSBrowser might crash in case of deeply nested filesystems.
   Please don't do this on a production system.
*/
void deleteRecursive(String path)
{
  File file = fileSystem->open(path, "r");
  bool isDir = file.isDirectory();
  file.close();

  // If it's a plain file, delete it
  if (!isDir)
  {
    fileSystem->remove(path);
    return;
  }

  // Otherwise delete its contents first
  Dir dir = fileSystem->openDir(path);

  while (dir.next())
  {
    deleteRecursive(path + '/' + dir.fileName());
  }

  // Then delete the folder itself
  fileSystem->rmdir(path);
}

/*
   Handle a file deletion request
   Operation      | req.responseText
   ---------------+--------------------------------------------------------------
   Delete file    | parent of deleted file, or remaining ancestor
   Delete folder  | parent of deleted folder, or remaining ancestor
*/
void handleFileDelete()
{
  if (!fsOK)
  {
    return replyServerError(FPSTR(FS_INIT_ERROR));
  }

  String path = server.arg(0);
  if (path.isEmpty() || path == "/")
  {
    return replyBadRequest("BAD PATH");
  }

  DBG_OUTPUT_PORT.println(String("handleFileDelete: ") + path);
  if (!fileSystem->exists(path))
  {
    return replyNotFound(FPSTR(FILE_NOT_FOUND));
  }
  deleteRecursive(path);

  replyOKWithMsg(lastExistingParent(path));
}

/*
   Handle a file upload request
*/
void handleFileUpload()
{
  if (!fsOK)
  {
    return replyServerError(FPSTR(FS_INIT_ERROR));
  }
  if (server.uri() != "/edit")
  {
    return;
  }
  HTTPUpload &upload = server.upload();
  if (upload.status == UPLOAD_FILE_START)
  {
    String filename = upload.filename;
    // Make sure paths always start with "/"
    if (!filename.startsWith("/"))
    {
      filename = "/" + filename;
    }
    DBG_OUTPUT_PORT.println(String("handleFileUpload Name: ") + filename);
    uploadFile = fileSystem->open(filename, "w");
    if (!uploadFile)
    {
      return replyServerError(F("CREATE FAILED"));
    }
    DBG_OUTPUT_PORT.println(String("Upload: START, filename: ") + filename);
  }
  else if (upload.status == UPLOAD_FILE_WRITE)
  {
    if (uploadFile)
    {
      size_t bytesWritten = uploadFile.write(upload.buf, upload.currentSize);
      if (bytesWritten != upload.currentSize)
      {
        return replyServerError(F("WRITE FAILED"));
      }
    }
    DBG_OUTPUT_PORT.println(String("Upload: WRITE, Bytes: ") + upload.currentSize);
  }
  else if (upload.status == UPLOAD_FILE_END)
  {
    if (uploadFile)
    {
      uploadFile.close();
    }
    DBG_OUTPUT_PORT.println(String("Upload: END, Size: ") + upload.totalSize);
  }
}

/*
   The "Not Found" handler catches all URI not explicitely declared in code
   First try to find and return the requested file from the filesystem,
   and if it fails, return a 404 page with debug information
*/
void handleNotFound()
{
  if (!fsOK)
  {
    return replyServerError(FPSTR(FS_INIT_ERROR));
  }

  String uri = ESP8266WebServer::urlDecode(server.uri()); // required to read paths with blanks

  if (handleFileRead(uri))
  {
    return;
  }

  // Dump debug data
  String message;
  message.reserve(100);
  message = F("Error: File not found\n\nURI: ");
  message += uri;
  message += F("\nMethod: ");
  message += (server.method() == HTTP_GET) ? "GET" : "POST";
  message += F("\nArguments: ");
  message += server.args();
  message += '\n';
  for (uint8_t i = 0; i < server.args(); i++)
  {
    message += F(" NAME:");
    message += server.argName(i);
    message += F("\n VALUE:");
    message += server.arg(i);
    message += '\n';
  }
  message += "path=";
  message += server.arg("path");
  message += '\n';
  DBG_OUTPUT_PORT.print(message);

  return replyNotFound(message);
}

/*
   This specific handler returns the index.htm (or a gzipped version) from the /edit folder.
   If the file is not present but the flag INCLUDE_FALLBACK_INDEX_HTM has been set, falls back to the version
   embedded in the program code.
   Otherwise, fails with a 404 page with debug information
*/
void handleGetEdit()
{
  if (handleFileRead(F("/edit/index.htm")))
  {
    return;
  }

#ifdef INCLUDE_FALLBACK_INDEX_HTM
  server.sendHeader(F("Content-Encoding"), "gzip");
  server.send(200, "text/html", index_htm_gz, index_htm_gz_len);
#else
  replyNotFound(FPSTR(FILE_NOT_FOUND));
#endif
}

// NOBODY = 0, SOMEONE = 1, LEFT = 0, RIGHT = 1
int ProcessPeopleCountingData(int16_t Distance, uint8_t zone)
{
  int CurrentZoneStatus = NOBODY;
  int AllZonesCurrentStatus = 0;
  int AnEventHasOccured = 0;

  if (Distance < threadhold)
  {
    // Someone is in !
    CurrentZoneStatus = SOMEONE;
  }

  // left zone
  if (zone == LEFT)
  {
    if (CurrentZoneStatus != LeftPreviousStatus)
    {
      // event in left zone has occured
      AnEventHasOccured = 1;
      if (CurrentZoneStatus == SOMEONE)
      {
        analogWrite(led1, 50);
        AllZonesCurrentStatus += 1;
      }
      else
      {
        analogWrite(led1, 0);
      }

      // need to check right zone as well ...
      if (RightPreviousStatus == SOMEONE)
      {
        // event in left zone has occured
        AllZonesCurrentStatus += 2;
      }
      // remember for next time
      LeftPreviousStatus = CurrentZoneStatus;
    }
  }
  // right zone
  else
  {
    if (CurrentZoneStatus != RightPreviousStatus)
    {

      // event in right zone has occured
      AnEventHasOccured = 1;
      if (CurrentZoneStatus == SOMEONE)
      {
        analogWrite(led2, 50);
        AllZonesCurrentStatus += 2;
      }
      else
      {
        analogWrite(led2, 0);
      }
      // need to left right zone as well ...
      if (LeftPreviousStatus == SOMEONE)
      {
        // event in left zone has occured
        AllZonesCurrentStatus += 1;
      }
      // remember for next time
      RightPreviousStatus = CurrentZoneStatus;
    }
  }

  // if an event has occured
  if (AnEventHasOccured)
  {
    if (PathTrackFillingSize < 4)
    {
      PathTrackFillingSize++;
    }

    // if nobody anywhere lets check if an exit or entry has happened
    if ((LeftPreviousStatus == NOBODY) && (RightPreviousStatus == NOBODY))
    {

      // check exit or entry only if PathTrackFillingSize is 4 (for example 0 1 3 2) and last event is 0 (nobobdy anywhere)
      if (PathTrackFillingSize == 4)
      {
        // check exit or entry. no need to check PathTrack[0] == 0 , it is always the case
        Serial.println();
        if ((PathTrack[1] == 1) && (PathTrack[2] == 3) && (PathTrack[3] == 2))
        {
          // This an entry
          PeopleCount++;
          Serial.print(F("Count: "));
          Serial.print(PeopleCount);
        }
        else if ((PathTrack[1] == 2) && (PathTrack[2] == 3) && (PathTrack[3] == 1))
        {
          // This an exit
          if (PeopleCount > 0)
          {
            PeopleCount--;
          }
          Serial.print(F("Count: "));
          Serial.print(PeopleCount);
        }
      }
      for (int i = 0; i < 4; i++)
      {
        PathTrack[i] = 0;
      }
      PathTrackFillingSize = 1;
    }
    else
    {
      // update PathTrack
      // example of PathTrack update
      // 0
      // 0 1
      // 0 1 3
      // 0 1 3 1
      // 0 1 3 3
      // 0 1 3 2 ==> if next is 0 : check if exit
      PathTrack[PathTrackFillingSize - 1] = AllZonesCurrentStatus;
      Serial.println();
      Serial.print(PathTrack[0]);
      Serial.print(",");
      Serial.print(PathTrack[1]);
      Serial.print(",");
      Serial.print(PathTrack[2]);
      Serial.print(",");
      Serial.print(PathTrack[3]);
      Serial.print("  ");
      if (zone == LEFT)
      {
        Serial.print(F("Left :"));
        Serial.print(Distance);
        Serial.print(F("\tRight:"));
        Serial.print(Distance0);
      }
      else
      {
        Serial.print(F("Left :"));
        Serial.print(Distance0);
        Serial.print(F("\tRight:"));
        Serial.print(Distance);
      }
      Serial.print(F("\t"));
      Serial.println(zone);
    }
  }

  // output debug data to main host machine
  Distance0 = Distance;
  return (PeopleCount);
}

void setup(void)
{
  ////////////////////////////////
  // SERIAL INIT
  DBG_OUTPUT_PORT.begin(115200);
  DBG_OUTPUT_PORT.setDebugOutput(true);
  DBG_OUTPUT_PORT.println("\nBooting Sketch...");

#if defined(ARDUINO_ARCH_ESP8266)
  FlashFS.begin();
#elif defined(ARDUINO_ARCH_ESP32)
  FlashFS.begin(true);
#endif

  loadAux(AUX_MQTTSETTING);
  loadAux(AUX_MQTTSAVE);

  loadAux(AUX_SETTING);
  loadAux(AUX_SETTINGSAVE);

  // Prepare the ESP8266HTTPUpdateServer
  // The /update handler will be registered during this function.
  httpUpdater.setup(&server, USERNAME, PASSWORD);

  ////////////////////////////////
  // FILESYSTEM INIT

  fileSystemConfig.setAutoFormat(false);
  fileSystem->setConfig(fileSystemConfig);
  fsOK = fileSystem->begin();

  DBG_OUTPUT_PORT.println(fsOK ? F("Filesystem initialized.") : F("Filesystem init failed!"));

#ifdef USE_SPIFFS
  // Debug: dump on console contents of filessytem with no filter and check filenames validity
  Dir dir = fileSystem->openDir("");
  DBG_OUTPUT_PORT.println(F("List of files at root of filesystem:"));
  while (dir.next())
  {
    String error = checkForUnsupportedPath(dir.fileName());
    String fileInfo = dir.fileName() + (dir.isDirectory() ? " [DIR]" : String(" (") + dir.fileSize() + "b)");
    DBG_OUTPUT_PORT.println(error + fileInfo);
    if (error.length() > 0)
    {
      unsupportedFiles += error + fileInfo + '\n';
    }
  }
  DBG_OUTPUT_PORT.println();

  // Keep the "unsupportedFiles" variable to show it, but clean it up
  unsupportedFiles.replace("\n", "<br/>");
  unsupportedFiles = unsupportedFiles.substring(0, unsupportedFiles.length() - 5);
#endif

  // With applying AutoConnect, making WiFi connection is not necessary.
  // WI-FI INIT
  // DBG_OUTPUT_PORT.printf("Connecting to %s\n", ssid);
  // WiFi.mode(WIFI_STA);
  // WiFi.begin(ssid, password);
  // // Wait for connection
  // while (WiFi.status() != WL_CONNECTED) {
  //   delay(500);
  //   DBG_OUTPUT_PORT.print(".");
  // }
  // DBG_OUTPUT_PORT.println("");
  // DBG_OUTPUT_PORT.print(F("Connected! IP address: "));
  // DBG_OUTPUT_PORT.println(WiFi.localIP());

  ////////////////////////////////
  // WEB SERVER INIT

  // Filesystem status
  server.on("/status", HTTP_GET, handleStatus);

  // List directory
  server.on("/list", HTTP_GET, handleFileList);

  // Load editor
  server.on("/edit", HTTP_GET, handleGetEdit);

  // Create file
  server.on("/edit", HTTP_PUT, handleFileCreate);

  // Delete file
  server.on("/edit", HTTP_DELETE, handleFileDelete);

  // Upload file
  // - first callback is called after the request has ended with all parsed arguments
  // - second callback handles file upload at that location
  server.on("/edit", HTTP_POST, replyOK, handleFileUpload);

  // Default handler for all URIs not defined above
  // Use it to read files from filesystem
  // To make AutoConnect recognize the 404 handler, replace it with:
  //server.onNotFound(handleNotFound);
  portal.onNotFound(handleNotFound);

  // Using AutoConnect does not require the HTTP server to be started
  // intentionally. It is launched inside AutoConnect.begin.
  // Start server
  // server.begin();
  // DBG_OUTPUT_PORT.println("HTTP server started");

  // Start AutoConnect
  config.title = "FSBrowser";
  //config.immediateStart = true;

  AutoConnectAux *MQTTsetting = portal.aux(AUX_MQTTSETTING);
  if (MQTTsetting)
  {
    PageArgument args;
    AutoConnectAux &mqtt_setting = *MQTTsetting;
    Serial.println("loadPrams");
    loadParams(mqtt_setting, args);
    AutoConnectCheckbox &uniqueidElm = mqtt_setting["uniqueid"].as<AutoConnectCheckbox>();
    AutoConnectInput &hostnameElm = mqtt_setting["hostname"].as<AutoConnectInput>();
    if (uniqueidElm.checked)
    {
      config.apid = String("ESP") + "-" + String(GET_CHIPID(), HEX);
      Serial.println("apid set to " + config.apid);
    }
    if (hostnameElm.value.length())
    {
      config.hostName = hostnameElm.value;
      Serial.println("hostname set to " + config.hostName);
    }
    config.homeUri = "/";

    portal.on(AUX_MQTTSETTING, loadParams);
    portal.on(AUX_MQTTSAVE, saveParams);
  }
  else
  {
    Serial.println("aux. load error");
  }

  /////////////////////////////////////////////////////////////////////
  AutoConnectAux *setting = portal.aux(AUX_SETTING);
  if (setting)
  {
    PageArgument args;
    AutoConnectAux &sensor_setting = *setting;
    Serial.println("loadPrams");
    loadSETTINGParams(sensor_setting, args);
    AutoConnectInput &_thread = sensor_setting["threadhold"].as<AutoConnectInput>();
    AutoConnectSelect &_direction = sensor_setting["direction"].as<AutoConnectSelect>();
    AutoConnectSelect &_led1 = sensor_setting["led1"].as<AutoConnectSelect>();
    AutoConnectSelect &_led2 = sensor_setting["led2"].as<AutoConnectSelect>();
    AutoConnectSelect &_button = sensor_setting["button"].as<AutoConnectSelect>();
    AutoConnectSelect &_modality = sensor_setting["modality"].as<AutoConnectSelect>();

    threadhold = _thread.value.toInt();
    if (_direction.value() == "좌->우")
    {
      center[0] = 167;
      center[1] = 231;
    }
    else if (_direction.value() == "우->좌")
    {
      center[0] = 231;
      center[1] = 167;
    }
    else if (_direction.value() == "위->아래")
    {
      center[0] = 188;
      center[1] = 88;
    }
    else if (_direction.value() == "아래->위")
    {
      center[0] = 88;
      center[1] = 188;
    }

    if (_led1.value() == "D0")
      led1 = D0;
    else if (_led1.value() == "D1")
      led1 = D1;
    else if (_led1.value() == "D2")
      led1 = D2;
    else if (_led1.value() == "D3")
      led1 = D3;
    else if (_led1.value() == "D4")
      led1 = D4;
    else if (_led1.value() == "D5")
      led1 = D5;
    else if (_led1.value() == "D6")
      led1 = D6;
    else if (_led1.value() == "D7")
      led1 = D7;
    else if (_led1.value() == "D8")
      led1 = D8;
    if (_led2.value() == "D0")
      led2 = D0;

    else if (_led2.value() == "D1")
      led2 = D1;
    else if (_led2.value() == "D2")
      led2 = D2;
    else if (_led2.value() == "D3")
      led2 = D3;
    else if (_led2.value() == "D4")
      led2 = D4;
    else if (_led2.value() == "D5")
      led2 = D5;
    else if (_led2.value() == "D6")
      led2 = D6;
    else if (_led2.value() == "D7")
      led2 = D7;
    else if (_led2.value() == "D8")
      led2 = D8;

    if (_button.value() == "D0")
      btn = D0;
    else if (_button.value() == "D1")
      btn = D1;
    else if (_button.value() == "D2")
      btn = D2;
    else if (_button.value() == "D3")
      btn = D3;
    else if (_button.value() == "D4")
      btn = D4;
    else if (_button.value() == "D5")
      btn = D5;
    else if (_button.value() == "D6")
      btn = D6;
    else if (_button.value() == "D7")
      btn = D7;
    else if (_button.value() == "D8")
      btn = D8;
    else if (_button.value() == "사용안함")
      btn = 0;

    if (_modality.selected == 1)
      modality = 1;
    else
      modality = 2;

    portal.on(AUX_SETTING, loadSETTINGParams);
    portal.on(AUX_SETTINGSAVE, saveSETTINGParams);

    Serial.print("led1:");
    Serial.println(led1);
    Serial.print("led2:");
    Serial.println(led2);
    Serial.print("btn:");
    Serial.println(btn);
  }
  else
  {
    Serial.println("aux. load error");
  }
  /////////////////////////////////////////////////////////////////////

  Wire.begin();
  Serial.println("VL53L1X Qwiic Test");
  if (distanceSensor.init() == false)
    Serial.println("Sensor online!");
  distanceSensor.setIntermeasurementPeriod(100);
  //distanceSensor.setDistanceModeLong();
  distanceSensor.setDistanceModeShort();

  pinMode(btn, INPUT_PULLUP);
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT);
  pinMode(BUILTIN_LED, OUTPUT);

  mp3.begin(9600);
  mp3.reset();
  mp3.setVolume(20);

  // Reconnect and continue publishing even if WiFi is disconnected.
  config.autoReconnect = false;
  config.reconnectInterval = 1;
  config.channel = 1;
  config.portalTimeout = 10000;
  config.retainPortal = true;
  portal.config(config);
  portal.append("/edit", "Edit");
  //portal.append("/list?dir=\"/\"", "List");
  portal.join({update});

  WiFiWebServer &webServer = portal.host();
  webServer.on(AUX_MQTTCLEAR, handleClearChannel);
  if (portal.begin())
  {
    DBG_OUTPUT_PORT.print(F("Connected! IP address: "));
    DBG_OUTPUT_PORT.println(WiFi.localIP());
  }
  DBG_OUTPUT_PORT.println("HTTP server started");
  Serial.print("셋업");
  analogWrite(led1,100);
  delay(100);
  analogWrite(led1,0);
  analogWrite(led1,100);
  delay(1000);
  analogWrite(led1,0);
  Serial.println(" 끝");
}

void loop(void)
{
  // To make AutoConnect recognize the client handling, replace it with:
  // server.handleClient();  // Invokes mDNS::update and AutoConnect::handleClient() for the menu processing.
  if (config.staip.isSet() || WiFi.softAPgetStationNum()>0)
  {
    portal.handleClient();
    if (updateInterval > 0)
    {
      if (millis() - lastPub > updateInterval)
      {
        if (!mqttClient.connected())
        {
          mqttConnect();
        }
        String item = String("field1=") + String(getStrength(7));
        mqttPublish(item);
        mqttClient.loop();
        lastPub = millis();
      }
    }
  }

  uint16_t distance;

  distanceSensor.setROI(ROI_height, ROI_width, center[Zone]); // first value: height of the zone, second value: width of the zone
  delay(50);
  distanceSensor.setTimingBudgetInMs(50);
  distanceSensor.startRanging();           //Write configuration bytes to initiate measurement
  distance = distanceSensor.getDistance(); //Get the result of the measurement from the sensor
  distanceSensor.stopRanging();

  // inject the new ranged distance in the people counting algorithm
  count = ProcessPeopleCountingData(distance, Zone);

  Zone++;
  Zone = Zone % 2;

  if (count == 0)
  {
    token = 1;
  }

  if ((count >= modality) && (token == 1)) //modality가 위장조영은 1, 유방촬영은 2
  {
    if (dtime0 == 0)
    {
      dtime0 = millis();
    }
    dtime1 = millis();
    if ((dtime1 - dtime0 > 10))
    {
      mp3.playFileByIndexNumber(modality);
      token = 0;
      dtime0 = 0;
      dtime1 = 0;
    }
  }

  button = digitalRead(btn);
  if (button == LOW)
  { //버튼 누름
    if (bt == 0)
    {
      t0 = millis();
      bt = 1;
    }
    if (bt == 1)
    {
      t = millis();
      if (t - t0 > 700 && longpress == 0)
      {
        count1 = 2;
        longpress = 1;
      }
    }
  }
  if (button == HIGH && bt == 1)
  { //손 땔때
    t = millis();
    if (t - t0 < 700)
    {
      count1 = 1;
    }
    bt = 0;
    t0 = 0;
    longpress = 0;
  }

  if (count1 == 1)
  {
    mp3.playFileByIndexNumber(3);
    count = 0;
    count1 = 0;
    PeopleCount = 0;
  }
  if (count1 == 2)
  {
    mp3.pause();
    count = 0;
    count1 = 0;
    PeopleCount = 0;
  }
  if (count == 0)
  {
    digitalWrite(BUILTIN_LED, HIGH);
    dtime0 = 0;
    dtime1 = 0;
  }
  if (count > 1)
  {
    digitalWrite(BUILTIN_LED, LOW);
  }
  if (count == 1)
  {
    if (digitalRead(BUILTIN_LED) == HIGH)
    {
      digitalWrite(BUILTIN_LED, LOW);
    }
    else
    {
      digitalWrite(BUILTIN_LED, HIGH);
    }
  }
}